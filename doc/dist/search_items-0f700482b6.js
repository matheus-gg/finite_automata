searchNodes=[{"doc":"This module implements an algorithm to simulate deterministic and non-deterministic finite automata.","ref":"FiniteAutomata.html","title":"FiniteAutomata","type":"module"},{"doc":"Validates the input for a given automata according to it's alphabet. If the input is valid, the input is deconstructed into a list of chars and passed to the next_state function, along with the initial state and the transition function. The next_state function will calculate the next state recursively, based on the transition function and the input given. If the automata gets trapped in a state without a valid transition, it will raise an error. If the input is completely consumed in the recursion, the function will return the final state(s). After the next_state function call, the result will be evaluated. If the input wasn't accepted, the compose_automata will raise an error. If final states can be reached, they will be compared to the acceptance_states, and if there is an intersection, the function will return an :accepted atom. Otherwise, it will raise another error.Examplesiex&gt; FiniteAutomata.compose_automata(&quot;abcd&quot;, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], [{:q0, &quot;a&quot;, :q1}, {:q1, &quot;b&quot;, :q2}, {:q2, &quot;c&quot;, :q1}, {:q1, &quot;b&quot;, :q3}], :q0, [:q3]) {:not_accepted, &quot;Input not valid for automata&#39;s alphabet.&quot;} iex&gt; FiniteAutomata.compose_automata(&quot;abc&quot;, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], [{:q0, &quot;a&quot;, :q1}, {:q1, &quot;b&quot;, :q2}, {:q2, &quot;c&quot;, :q1}, {:q1, &quot;b&quot;, :q3}], :q0, [:q3]) {:not_accepted, &quot;Automata is trapped in a non-acceptance state after consuming the input.&quot;} iex&gt; FiniteAutomata.compose_automata(&quot;abc&quot;, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], [{:q0, &quot;a&quot;, :q1}, {:q1, &quot;c&quot;, :q2}, {:q2, &quot;b&quot;, :q1}, {:q1, &quot;c&quot;, :q3}], :q0, [:q3]) {:not_accepted, &quot;Automata is trapped in a state with no valid transition for the given input.&quot;} iex&gt; FiniteAutomata.compose_automata(&quot;abc&quot;, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], [{:q0, &quot;a&quot;, :q1}, {:q1, &quot;b&quot;, :q2}, {:q2, &quot;c&quot;, :q1}, {:q1, &quot;b&quot;, :q3}], :q0, [:q1]) {:accepted}","ref":"FiniteAutomata.html#compose_automata/5","title":"FiniteAutomata.compose_automata/5","type":"function"},{"doc":"Calculates the next state for the deconstructed input, following the rules of the transition function. If no next state can be found, the function returns an :empty atom, that will be evaluated in a :not_accepted return. If one or more next states can be found at the end of the recursion, the function returns a list with the next state(s).Examplesiex&gt; FiniteAutomata.next_state([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], [:q0], [{:q0, &quot;a&quot;, :q1}, {:q1, &quot;b&quot;, :q2}, {:q2, &quot;c&quot;, :q3}]) [:q3] iex&gt; FiniteAutomata.next_state([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;b&quot;], [:q0], [{:q0, &quot;a&quot;, :q1}, {:q1, &quot;b&quot;, :q2}, {:q2, &quot;c&quot;, :q1}, {:q1, &quot;b&quot;, :q3}]) [:q2, :q3] iex&gt; FiniteAutomata.next_state([&quot;b&quot;], [:q0], [{:q0, &quot;a&quot;, :q1}, {:q1, &quot;b&quot;, :q2}]) :not_accepted","ref":"FiniteAutomata.html#next_state/3","title":"FiniteAutomata.next_state/3","type":"function"},{"doc":"Validates input according to automata's alphabet.Examplesiex&gt; FiniteAutomata.validate_input(&quot;abc&quot;, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) :valid iex&gt; FiniteAutomata.validate_input(&quot;abc&quot;, [&quot;a&quot;, &quot;b&quot;, &quot;d&quot;]) :invalid","ref":"FiniteAutomata.html#validate_input/2","title":"FiniteAutomata.validate_input/2","type":"function"}]