searchNodes=[{"doc":"This module implements an algorithm to simulate deterministic and non-deterministic finite automata. A finite automata is formally represented by a 5-tuple &lt;Q, S, D, Q0, F&gt;, where: Q is a finite set of states.S is a finite set of symbols, called the alphabet of the automaton.D is the transition function, that is, D: Q x S -&gt; Q.Q0 is the start state, that is, the state of the automaton before any input has been processed, where Q0 ∈ Q.F is a set of states of Q (i.e. F ⊆ Q) called accept states. Another important concept is the input word, that is a string of symbols a1,a2,....,an, where ai ∈ S, that is read by the automaton. The set of all words is denoted by S*. After the consumption of the input by the automaton, it reaches a final state, denoted by Qn. A word w ∈ S* is accepted by the automaton if Qn ∈ F. The algorithm consists of a initial validation of the input based on the alphabet and a recursive logic to go through the states of the automaton based on the input given, according to the transition function. The algorithm is built to simulate deterministic and non-deterministic finite automata, including non-deterministic with empty transitions. Is heavily based on the Enum library of Elixir, used to deal with lists.","ref":"FiniteAutomata.html","title":"FiniteAutomata","type":"module"},{"doc":"Validates the input for a given automata according to it's alphabet. If the input is valid, the input is deconstructed into a list of chars and passed to the next_state function, along with the initial state and the transition function. The next_state function will calculate the next state recursively, based on the transition function and the input given. If the automata gets trapped in a state without a valid transition, it will raise an error. If the input is completely consumed in the recursion, the function will return the final state(s). After the next_state function call, the result will be evaluated. If the input wasn't accepted, the compose_automata will raise an error. If final states can be reached, they will be compared to the acceptance_states, and if there is an intersection, the function will return an :accepted atom. Otherwise, it will raise another error.Parametersinput: The input tape that will be evaluated on the finite automata. Must be a string.alphabet: A list of the symbols accepted by the automata. The symbols must be represented in a string form.transition_function: A list of tuples representing the rules for the transition function. The form o the tuples is {:q0, &quot;x&quot;, :q1}, representing the initial state, symbol triggering the transition and the next state.initial_state: Atom representing the initial state for the automaton. The convention in the tests is using :qn, n &gt;=0.acceptance_states: Set of acceptance states. Is a list of atoms, used to compare the result of the input path on the automaton, to check if the input is recognized by the automaton.Examplesiex&gt; FiniteAutomata.compose_automata(&quot;abcd&quot;, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], [{:q0, &quot;a&quot;, :q1}, {:q1, &quot;b&quot;, :q2}, {:q2, &quot;c&quot;, :q1}, {:q1, &quot;b&quot;, :q3}], :q0, [:q3]) {:not_accepted, &quot;Input not valid for automaton&#39;s alphabet.&quot;} iex&gt; FiniteAutomata.compose_automata(&quot;abc&quot;, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], [{:q0, &quot;a&quot;, :q1}, {:q1, &quot;b&quot;, :q2}, {:q2, &quot;c&quot;, :q1}, {:q1, &quot;b&quot;, :q3}], :q0, [:q3]) {:not_accepted, &quot;Automaton is trapped in a non-acceptance state after consuming the input.&quot;} iex&gt; FiniteAutomata.compose_automata(&quot;abc&quot;, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], [{:q0, &quot;a&quot;, :q1}, {:q1, &quot;c&quot;, :q2}, {:q2, &quot;b&quot;, :q1}, {:q1, &quot;c&quot;, :q3}], :q0, [:q3]) {:not_accepted, &quot;Automaton is trapped in a state with no valid transition for the given input.&quot;} iex&gt; FiniteAutomata.compose_automata(&quot;abc&quot;, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], [{:q0, &quot;a&quot;, :q1}, {:q1, &quot;b&quot;, :q2}, {:q2, &quot;c&quot;, :q1}, {:q1, &quot;b&quot;, :q3}], :q0, [:q1]) {:accepted}","ref":"FiniteAutomata.html#compose_automata/5","title":"FiniteAutomata.compose_automata/5","type":"function"},{"doc":"Calculates the next state for the deconstructed input, following the rules of the transition function. If no next state can be found, the function returns an :empty atom, that will be evaluated in a :trapped return. If one or more next states can be found at the end of the recursion, the function returns a list with the next state(s).Parametersinput_chars: Input string deconstructed in a list of chars, used to iterate the next_state function to find a path on the automaton.current_state: The current state of the automaton. Used as parameter to scroll through the transition function, seeking for transition symbols and next states.transition_function: A list of tuples representing the rules for the transition function. The form o the tuples is {:q0, &quot;x&quot;, :q1}, representing the initial state, symbol triggering the transition and the next state.Examplesiex&gt; FiniteAutomata.next_state([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], [:q0], [{:q0, &quot;a&quot;, :q1}, {:q1, &quot;b&quot;, :q2}, {:q2, &quot;c&quot;, :q3}]) [:q3] iex&gt; FiniteAutomata.next_state([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;b&quot;], [:q0], [{:q0, &quot;a&quot;, :q1}, {:q0, nil, :q2}, {:q1, &quot;b&quot;, :q2}, {:q2, &quot;c&quot;, :q1}, {:q1, &quot;b&quot;, :q3}]) [:q2, :q3] iex&gt; FiniteAutomata.next_state([&quot;b&quot;], [:q0], [{:q0, &quot;a&quot;, :q1}, {:q1, &quot;b&quot;, :q2}]) :trapped","ref":"FiniteAutomata.html#next_state/3","title":"FiniteAutomata.next_state/3","type":"function"},{"doc":"Validates input according to automata's alphabet. If the input contains a symbol not present on the automaton's alphabet, the function returns an :invalid atom. Otherwise, it will return a :valid atom.Parametersinput: The input tape that will be evaluated on the finite automata. Must be a string.alphabet: A list of the symbols accepted by the automata. The symbols must be represented in a string form.Examplesiex&gt; FiniteAutomata.validate_input(&quot;abc&quot;, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) :valid iex&gt; FiniteAutomata.validate_input(&quot;abc&quot;, [&quot;a&quot;, &quot;b&quot;, &quot;d&quot;]) :invalid","ref":"FiniteAutomata.html#validate_input/2","title":"FiniteAutomata.validate_input/2","type":"function"}]